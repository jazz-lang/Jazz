struct Entry<K: Cmp,V> {
    var key: K*;
    var value: mut V*;

    init(key: K,val: V) {
        value = alloc<V>(val);
        this.key = alloc<K>(key);
    }
}

/// Very slow map implementation.
struct Map<K: Cmp,V> {
    var entries: Array<(key: mut K,value: mut V*)>;

    init() {
        entries = Array<(key: mut K,value: mut V*)>(cap: 32);
    }

    mut fun [](key: K): mut V* {
        if (!contains(key)) {
            insert(key,V());
        }
        return getMut(key)!;
    }

    mut fun insert(key: K): bool {
        for (var entry in entries) {
            if (entry.key == key) {
                return false;
            }
        }
        var pos = size();
        entries.reserve(1);
        entries[pos].key = key;
        return true;
    }

    mut fun insert(key: K,value_: V): bool {
        var value = alloc<V>(value_);
        for (var entry in entries) {
            if (entry.key == key) {
                *entry.value = value;
                return false;
            }
        }
        
        entries.push((key,value));

        return true;
    }

    fun get(key: K): V*? {
        for (const entry in entries) {
            if (entry.key == key) {
                return entry.value;
            }
        }
        return null;
    }

    mut fun get(key: K): mut V*?{
        for (var entry in entries) {
            if (entry.key == key) {
                return entry.value;
            }
        }
        return null;
    }

    mut fun getMut(key: K): mut V*?{
        for (var entry in entries) {
            if (entry.key == key) {
                return entry.value;
            }
        }
        return null;
    }



    fun contains(key: K): bool {
        for (const entry in entries) {
            if (entry.key == key) {
                return true;
            }
        }
        return false;
    }

    

    fun size(): int {
        return entries.size();
    }

    fun empty(): bool {
        return size() == 0;
    }

    mut fun remove(key: K) {
        for (var i in 0..size()) {
            if (entries[i].key == key) {
                entries.removeAt(i);
                break;
            }
        }
    }

    fun iterator(): MapIterator<K,V> {
        return MapIterator(this);
    }
}

struct MapIterator<K,V>: Copy,Iterator<(key: mut K,value: mut V*)*> {
    var iterator: ArrayIterator<(key: mut K,value: mut V*)>;
    var current: (key: K,value: mut V*)*;
    init(map: Map<K,V>*) {
        iterator = map.entries.iterator();
        current = iterator.value();
    }

    fun hasValue(): bool {
        return iterator.hasValue();
    }

    fun value():(key: mut K,value: mut V*)* {
        return current;
    }

    mut fun increment() {
        iterator.increment();
        current = iterator.value();
    }
}