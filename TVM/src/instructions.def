INSTRUCTION(InsIconst, 2)    // Move integer constant B to R(A)
INSTRUCTION(InsFconst, 2)    // Move float constant B to R(A)
INSTRUCTION(InsBconst, 2)    // Move boolean constant B to R(A)
INSTRUCTION(InsBytesLoad, 2) // Move bytes from pool at B to R(A)
INSTRUCTION(InsStrConst, 2)  // Move string from pool at B to R(A)
INSTRUCTION(InsNullConst, 1) // Move null constant to R(A)
INSTRUCTION(InsMov, 2)       // Move value from R(A) to R(B)

INSTRUCTION(InsAdd, 3)  // R(A) = R(B) + R(C)
INSTRUCTION(InsSub, 3)  // R(A) = R(B) - R(C)
INSTRUCTION(InsMul, 3)  // R(A) = R(B) * R(C)
INSTRUCTION(InsDiv, 3)  // R(A) = R(B) / R(C)
INSTRUCTION(InsMod, 3)  // R(A) = R(B) % R(C)
INSTRUCTION(InsShl, 3)  // R(A) = R(B) << R(C)
INSTRUCTION(InsSShr, 3) // R(A) = R(B) >> R(C)
INSTRUCTION(InsUShr, 3) // R(A) = R(B) >> R(C)
INSTRUCTION(
    InsAnd,
    3) // if R(B) and R(C) booleans: R(A) = R(B) && R(C) else R(A) = R(B) & R(C)
INSTRUCTION(
    InsOr,
    3)                 // if R(B) and R(C) booleans: R(A) = R(B) || R(C) else R(A) = R(B) | R(C)
INSTRUCTION(InsXOR, 3) // R(A) = R(B) ^ R(C)

INSTRUCTION(InsNeg, 2)            // R(A) = -R(B)
INSTRUCTION(InsNot, 2)            // R(A) = ~R(B)
INSTRUCTION(InsInvoke, -1)        // R(A) = invoke R(A) args
INSTRUCTION(InsInvoke0, 2)        // R(A) = invoke R(A) [R(B)]
INSTRUCTION(InsInvoke1, 3)        // R(A) = invoke R(A) [R(B),R(C)]
INSTRUCTION(InsInvoke2, 4)        // R(A) = invoke R(A) [R(B),R(C),R(F)]
INSTRUCTION(InsInvoke3, 5)        // R(A) = invoke R(A) [R(B),R(C),R(F),R(G)]
INSTRUCTION(InsInvoke4, 6)        // R(A) = invoke R(A) [R(B),R(C),R(F),R(G),R(H)]
INSTRUCTION(InsInvokeField, -1)   // R(A) = invoke R(A) args
INSTRUCTION(InsInvokeThis, -1)    // R(A) = invoke R(A) args
INSTRUCTION(InsInvokeClosure, -1) // R(A) = invoke R(A) args
INSTRUCTION(InsLoadGlobal, 2)     // R(A) = G(B)
INSTRUCTION(InsStoreGlobal, 2)    // G(A) = R(A)
INSTRUCTION(InsLoadThis, 2)
INSTRUCTION(InsStoreThis, 2)
INSTRUCTION(InsGetField, 3)       // R(A) = R(B)[R(C)]
INSTRUCTION(InsStoreField, 3)     // R(B)[R(C)] = R(A)
INSTRUCTION(InsHybridLoad, 3)
INSTRUCTION(InsHybridStore, 3)
INSTRUCTION(InsBrNz, 2) // Branch if not zero R(A) <B>
INSTRUCTION(InsBrZ, 2) // Branch if zero R(A) <B>
INSTRUCTION(InsBrNull, 2) // Branch if null (alias to BrZ) R(A) <B>
INSTRUCTION(InsBrLt, 3) // Branch if less R(A) < R(B)
INSTRUCTION(InsBrGt, 3) // Branch if greater R(A) > (B) <C>
INSTRUCTION(InsBrGte, 3) // Branch if greater or equal R(A) >= R(B) <C>
INSTRUCTION(InsBrLte, 3) // Branch if less or equal R(A) <= R(B) <C>
INSTRUCTION(InsBrULt, 3) // Branch if less (unsigned version) R(A) < R(B) <C>
INSTRUCTION(InsBrUGt, 3) // Branch if greater (unsigned version) R(A) > R(B)<C>
INSTRUCTION(InsBrUGte, 3) // Branch if greater or equal (unsigned version) R(A) >= R(B) <C>
INSTRUCTION(InsBrULte, 3) // Branch if less or equal (unsigned version) R(A) <= R(B) <C>
INSTRUCTION(InsUDiv, 3) // R(A) = R(C) / R(B) (unsigned version)
INSTRUCTION(InsUMod, 3) // R(A) = R(C) % R(B) (unsigned version)
INSTRUCTION(InsCastToHybrid, 2) // Cast value to Hybrid (a.k.a DynObj)
INSTRUCTION(InsCastToFloat, 2) // Cast value to float
INSTRUCTION(InsCastToUFloat, 2) // Float from bits
INSTRUCTION(InsCastToInt, 2) // Cast value to integer
INSTRUCTION(InsCastSafe, 2) // Safe cast value R(B) to Type(A) 
INSTRUCTION(InsCastBitcast, 2) // Bitcast value R(B) to Type(A)
INSTRUCTION(InsCastToVirt, 2) // Cast value to virtual value
INSTRUCTION(InsCheckNull, 1) // R(A) == null
INSTRUCTION(InsLabel, 0) // Create label (used for jumps)
INSTRUCTION(InsRet, 1) // Return R(A) 
INSTRUCTION(InsRetVoid, 0) // Return void 
INSTRUCTION(InsThrow, 1) // Throw exception R(A)
INSTRUCTION(InsReThrow, 1) // Rethrow exception
INSTRUCTION(InsBranchTable, -1) // Branch table

INSTRUCTION(InsTrap, 2) 
INSTRUCTION(InsEndTrap, 1)
INSTRUCTION(InsLoadI8, 3)
INSTRUCTION(InsLoadI16, 3)
INSTRUCTION(InsLoadI32, 3)
INSTRUCTION(InsLoadMem, 3)
INSTRUCTION(InsLoadSIMDVector, 3)
INSTRUCTION(InsLoadSizedArray, 3)
INSTRUCTION(InsStoreI8, 3)
INSTRUCTION(InsStoreI16, 3)
INSTRUCTION(InsStoreI32, 3)
INSTRUCTION(InsStoreMem, 3)
INSTRUCTION(InsStoreSIMDVector, 3)
INSTRUCTION(InsStoreSizedArray, 3)

INSTRUCTION(InsInit, 1)
INSTRUCTION(InsGetArraySize, 2)
INSTRUCTION(InsRef, 2)
INSTRUCTION(InsWeakRef, 2)
INSTRUCTION(InsDeref, 2)
INSTRUCTION(InsSetRef, 2)
INSTRUCTION(InsRefData, 2)
INSTRUCTION(InsRefLoad, 3)
INSTRUCTION(InsNop, 0)
INSTRUCTION(BrNzS, 2) // BrNz short form
INSTRUCTION(BrZS,2) // BrZ short form
INSTRUCTION(BrNullS,2) // BrNull short form
INSTRUCTION(BrS,1) // Br short form
INSTRUCTION(InsLast, 0)